/*
 * Copyright (C) 2008  Bernhard Hobiger
 *
 * This file is part of HoDoKu.
 *
 * HoDoKu is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * HoDoKu is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with HoDoKu. If not, see <http://www.gnu.org/licenses/>.
 */

package sudoku;

import java.util.Enumeration;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.JOptionPane;
import javax.swing.event.TreeSelectionEvent;
import javax.swing.event.TreeSelectionListener;
import javax.swing.tree.DefaultMutableTreeNode;
import javax.swing.tree.DefaultTreeModel;
import javax.swing.tree.TreePath;
import javax.swing.tree.TreeSelectionModel;

/**
 *
 * @author  Bernhard Hobiger
 */
public class AllStepsPanel extends javax.swing.JPanel implements TreeSelectionListener, Runnable {
    private Sudoku sudoku;
    private MainFrame mainFrame;
    private DefaultTreeModel model;
    private List<SolutionStep> steps;
    
    /** Creates new form AllStepsPanel */
    public AllStepsPanel(MainFrame mainFrame, Sudoku sudoku) {
        this.mainFrame = mainFrame;
        this.setSudoku(sudoku);
        
        initComponents();
        
        resetPanel();
        stepsTree.getSelectionModel().setSelectionMode(TreeSelectionModel.SINGLE_TREE_SELECTION);
        stepsTree.addTreeSelectionListener(this);
        
        setCheckBoxes();
    }
    
    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jPanel1 = new javax.swing.JPanel();
        forcingChainsCheckBox = new javax.swing.JCheckBox();
        forcingNetsCheckBox = new javax.swing.JCheckBox();
        krakenFishCheckBox = new javax.swing.JCheckBox();
        configureButton = new javax.swing.JButton();
        jPanel2 = new javax.swing.JPanel();
        findButton = new javax.swing.JButton();
        addToSolutionButton = new javax.swing.JButton();
        jScrollPane1 = new javax.swing.JScrollPane();
        stepsTree = new javax.swing.JTree();

        setLayout(new java.awt.BorderLayout());

        java.util.ResourceBundle bundle = java.util.ResourceBundle.getBundle("intl/AllStepsPanel"); // NOI18N
        jPanel1.setBorder(javax.swing.BorderFactory.createTitledBorder(bundle.getString("AllStepsPanel.jPanel1.border.title"))); // NOI18N

        forcingChainsCheckBox.setMnemonic(java.util.ResourceBundle.getBundle("intl/AllStepsPanel").getString("AllStepsPanel.forcingChainsCheckBox.mnemonic").charAt(0));
        forcingChainsCheckBox.setText(bundle.getString("AllStepsPanel.forcingChainsCheckBox.text")); // NOI18N
        forcingChainsCheckBox.setBorder(javax.swing.BorderFactory.createEmptyBorder(0, 0, 0, 0));
        forcingChainsCheckBox.setMargin(new java.awt.Insets(0, 0, 0, 0));
        forcingChainsCheckBox.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                forcingChainsCheckBoxActionPerformed(evt);
            }
        });

        forcingNetsCheckBox.setMnemonic(java.util.ResourceBundle.getBundle("intl/AllStepsPanel").getString("AllStepsPanel.forcingNetsCheckBox.mnemonic").charAt(0));
        forcingNetsCheckBox.setText(bundle.getString("AllStepsPanel.forcingNetsCheckBox.text")); // NOI18N
        forcingNetsCheckBox.setBorder(javax.swing.BorderFactory.createEmptyBorder(0, 0, 0, 0));
        forcingNetsCheckBox.setMargin(new java.awt.Insets(0, 0, 0, 0));
        forcingNetsCheckBox.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                forcingNetsCheckBoxActionPerformed(evt);
            }
        });

        krakenFishCheckBox.setMnemonic(java.util.ResourceBundle.getBundle("intl/AllStepsPanel").getString("AllStepsPanel.krakenFishCheckBox.mnemonic").charAt(0));
        krakenFishCheckBox.setText(bundle.getString("AllStepsPanel.krakenFishCheckBox.text")); // NOI18N
        krakenFishCheckBox.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                krakenFishCheckBoxActionPerformed(evt);
            }
        });

        configureButton.setMnemonic(java.util.ResourceBundle.getBundle("intl/AllStepsPanel").getString("AllStepsPanel.configureButton.mnemonic").charAt(0));
        configureButton.setText(bundle.getString("AllStepsPanel.configureButton.text")); // NOI18N
        configureButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                configureButtonActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);
        jPanel1.setLayout(jPanel1Layout);
        jPanel1Layout.setHorizontalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addComponent(forcingChainsCheckBox)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(forcingNetsCheckBox)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(krakenFishCheckBox))
                    .addComponent(configureButton))
                .addContainerGap(171, Short.MAX_VALUE))
        );
        jPanel1Layout.setVerticalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(forcingChainsCheckBox)
                    .addComponent(forcingNetsCheckBox)
                    .addComponent(krakenFishCheckBox))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(configureButton)
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        add(jPanel1, java.awt.BorderLayout.PAGE_START);

        findButton.setMnemonic(java.util.ResourceBundle.getBundle("intl/AllStepsPanel").getString("AllStepsPanel.findButton.mnemonic").charAt(0));
        findButton.setText(bundle.getString("AllStepsPanel.findButton.text")); // NOI18N
        findButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                findButtonActionPerformed(evt);
            }
        });

        addToSolutionButton.setMnemonic(java.util.ResourceBundle.getBundle("intl/AllStepsPanel").getString("AllStepsPanel.addToSolution.mnemonic").charAt(0));
        addToSolutionButton.setText(bundle.getString("AllStepsPanel.addToSolutionButton.text")); // NOI18N
        addToSolutionButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                addToSolutionButtonActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout jPanel2Layout = new javax.swing.GroupLayout(jPanel2);
        jPanel2.setLayout(jPanel2Layout);
        jPanel2Layout.setHorizontalGroup(
            jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel2Layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(findButton)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(addToSolutionButton)
                .addContainerGap(214, Short.MAX_VALUE))
        );

        jPanel2Layout.linkSize(javax.swing.SwingConstants.HORIZONTAL, new java.awt.Component[] {addToSolutionButton, findButton});

        jPanel2Layout.setVerticalGroup(
            jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel2Layout.createSequentialGroup()
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(findButton)
                    .addComponent(addToSolutionButton))
                .addContainerGap())
        );

        add(jPanel2, java.awt.BorderLayout.SOUTH);

        jScrollPane1.setViewportView(stepsTree);

        add(jScrollPane1, java.awt.BorderLayout.CENTER);
    }// </editor-fold>//GEN-END:initComponents
    
    private void addToSolutionButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_addToSolutionButtonActionPerformed
        DefaultMutableTreeNode last = (DefaultMutableTreeNode)stepsTree.getLastSelectedPathComponent();
        SolutionStep actStep = null;
        if (last != null) {
            if (last.getUserObject() instanceof String) {
                // Erstes Step-Kind holen
                Enumeration children = last.children();
                while (children.hasMoreElements()) {
                    DefaultMutableTreeNode act = (DefaultMutableTreeNode)children.nextElement();
                    if (act.getUserObject() instanceof SolutionStep) {
                        actStep = (SolutionStep)act.getUserObject();
                        break;
                    }
                }
            } else {
                actStep = (SolutionStep)last.getUserObject();
            }
        }
        if (actStep == null) {
            JOptionPane.showMessageDialog(this, java.util.ResourceBundle.getBundle("intl/AllStepsPanel").getString("AllStepsPanel.no_solution_selected"), 
                    java.util.ResourceBundle.getBundle("intl/AllStepsPanel").getString("AllStepsPanel.error"), JOptionPane.ERROR_MESSAGE);
            return;
        }
        mainFrame.getSolutionPanel().addStep(actStep);
    }//GEN-LAST:event_addToSolutionButtonActionPerformed
    
    private void findButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_findButtonActionPerformed
        if (sudoku == null) {
            JOptionPane.showMessageDialog(this, java.util.ResourceBundle.getBundle("intl/AllStepsPanel").getString("AllStepsPanel.sudoku_not_set"), 
                    java.util.ResourceBundle.getBundle("intl/AllStepsPanel").getString("AllStepsPanel.error"), JOptionPane.ERROR_MESSAGE);
            return;
        }
        resetTreeNodes();
        new Thread(this).start();
    }//GEN-LAST:event_findButtonActionPerformed

private void configureButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_configureButtonActionPerformed
    new ConfigDialog(mainFrame, true, 2).setVisible(true);
    setCheckBoxes();
}//GEN-LAST:event_configureButtonActionPerformed

private void forcingChainsCheckBoxActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_forcingChainsCheckBoxActionPerformed
    adjustAllStepsEnabled(SolutionType.FORCING_CHAIN, forcingChainsCheckBox.isSelected());
    adjustAllStepsEnabled(SolutionType.FORCING_CHAIN_CONTRADICTION, forcingChainsCheckBox.isSelected());
    adjustAllStepsEnabled(SolutionType.FORCING_CHAIN_VERITY, forcingChainsCheckBox.isSelected());
}//GEN-LAST:event_forcingChainsCheckBoxActionPerformed

private void forcingNetsCheckBoxActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_forcingNetsCheckBoxActionPerformed
    adjustAllStepsEnabled(SolutionType.FORCING_NET, forcingNetsCheckBox.isSelected());
    adjustAllStepsEnabled(SolutionType.FORCING_NET_CONTRADICTION, forcingNetsCheckBox.isSelected());
    adjustAllStepsEnabled(SolutionType.FORCING_NET_VERITY, forcingNetsCheckBox.isSelected());
}//GEN-LAST:event_forcingNetsCheckBoxActionPerformed

private void krakenFishCheckBoxActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_krakenFishCheckBoxActionPerformed
    adjustAllStepsEnabled(SolutionType.KRAKEN_FISH, krakenFishCheckBox.isSelected());
}//GEN-LAST:event_krakenFishCheckBoxActionPerformed
      
    private void adjustAllStepsEnabled(SolutionType type, boolean allStepsEnabled) {
        StepConfig[] tmpSteps = Options.getInstance().solverSteps;
        for (int i = 0; i < tmpSteps.length; i++) {
            if (tmpSteps[i].getType() == type) {
                tmpSteps[i].setAllStepsEnabled(allStepsEnabled);
            }
        }
    }

    private boolean getAllStepsEnabled(SolutionType type) {
        StepConfig[] tmpSteps = Options.getInstance().solverSteps;
        for (int i = 0; i < tmpSteps.length; i++) {
            if (tmpSteps[i].getType() == type) {
                return tmpSteps[i].isAllStepsEnabled();
            }
        }
        return false;
    }
    
    private void setCheckBoxes() {
        forcingChainsCheckBox.setSelected(getAllStepsEnabled(SolutionType.FORCING_CHAIN));
        forcingNetsCheckBox.setSelected(getAllStepsEnabled(SolutionType.FORCING_NET));
        krakenFishCheckBox.setSelected(getAllStepsEnabled(SolutionType.KRAKEN_FISH));
    }
    
    @Override
    public void run() {
        FindAllStepsProgressDialog dlg = new FindAllStepsProgressDialog(mainFrame, true, sudoku);
        dlg.setVisible(true);
        steps = dlg.getSteps();
        createTreeNodes();
    }
    
    public void resetPanel() {
        model = new DefaultTreeModel(new DefaultMutableTreeNode(java.util.ResourceBundle.getBundle("intl/AllStepsPanel").getString("AllStepsPanel.no_solutions")));
        stepsTree.setModel(model);
        createTreeNodes();
    }
    
    private void resetTreeNodes() {
        DefaultMutableTreeNode root = (DefaultMutableTreeNode)model.getRoot();
        root.removeAllChildren();
        root.setUserObject(java.util.ResourceBundle.getBundle("intl/AllStepsPanel").getString("AllStepsPanel.searching"));
        model.reload();
        stepsTree.setRootVisible(true);
        stepsTree.repaint();
    }
    
    private void createTreeNodes() {
        DefaultMutableTreeNode root = (DefaultMutableTreeNode)model.getRoot();
        root.removeAllChildren();
        if (steps != null && steps.size() > 0) {
            root.setUserObject(java.util.ResourceBundle.getBundle("intl/AllStepsPanel").getString("AllStepsPanel.possible_steps"));
            stepsTree.setRootVisible(false);
            SolutionStep lastStep = null;
            DefaultMutableTreeNode lastCat = null;
            DefaultMutableTreeNode lastEntry = null;
            for (SolutionStep step : steps) {
                // Singles kommen immer ganz oben hin (jedes Single in eine eigene Kategorie); das gleiche gilt für Forcing Chains, die Werte setzen
                // (eigener Durchlauf!)
                //System.out.println(step.toString(2));
                if (step.isSingle() || (step.isForcingChainSet())) {
                    continue;
                }
                Logger.getLogger(AllStepsPanel.class.getName()).log(Level.FINER, step.toString(2));
                if (lastStep == null) {
                    // erster Eintrag
                    Logger.getLogger(AllStepsPanel.class.getName()).log(Level.FINER, step.getCandidateString());
                    lastCat = new DefaultMutableTreeNode(step.getCandidateString());
                    lastEntry = new DefaultMutableTreeNode(step);
                    root.add(lastCat);
                    lastCat.add(lastEntry);
                } else {
                    // normaler Betrieb, mitten im Baum
                    if (step.isEqual(lastStep)) {
                        // gleich -> darunterhängen
                        lastEntry.add(new DefaultMutableTreeNode(step));
                    } else if (step.isEquivalent(lastStep)) {
                        // äquivalent: neuer Eintrag unter lastCat
                        lastEntry = new DefaultMutableTreeNode(step);
                        lastCat.add(lastEntry);
                    } else {
                        // neue Kategorie: prüfen, ob es ein Subset eines bestehenden Eintrags ist
                        Logger.getLogger(AllStepsPanel.class.getName()).log(Level.FINER, step.getCandidateString());
                        lastCat = new DefaultMutableTreeNode(step.getCandidateString());
                        lastEntry = new DefaultMutableTreeNode(step);
                        // doch nicht untereinander
                        //DefaultMutableTreeNode tmp = getParent(root, step);
                        DefaultMutableTreeNode tmp = null;
                        if (tmp == null) {
                            // in oberster Ebene einhängen: richtigen Index suchen
                            // (soll schließlich nach Anzahl zu löschender Kandidaten sortiert sein)
                            root.insert(lastCat, getTopLevelIndex(root, step));
                            //root.add(lastCat);
                        } else {
                            // ist entweder äquivalent oder Subset
                            SolutionStep tmpStep = getStepFromNode(tmp);
                            if (tmpStep.isEquivalent(step)) {
                                // hinter dem äquivalenten Step in parent einfügen
                                DefaultMutableTreeNode parent = (DefaultMutableTreeNode)tmp.getParent();
                                parent.insert(lastCat, parent.getIndex(tmp) + 1);
                            } else {
                                tmp.add(lastCat);
                            }
                        }
                        lastCat.add(lastEntry);
                    }
                }
                lastStep = step;
            }
            for (SolutionStep step : steps) {
                // Singles kommen immer ganz oben hin (jedes Single in eine eigene Kategorie)
                // ACHTUNG: Forcing Chains: Alle Setzoperationen für eine Zelle in eine Kategorie
                // (eigener Durchlauf!)
                if (! step.isSingle() && ! step.isForcingChainSet()) {
                    continue;
                }
                if (step.isForcingChainSet() && step.isEqual(lastStep)) {
                    // gleich -> darunterhängen
                    lastEntry.add(new DefaultMutableTreeNode(step));
                } else {
                    lastCat = new DefaultMutableTreeNode(step.getSingleCandidateString());
                    lastEntry = new DefaultMutableTreeNode(step);
                    root.insert(lastCat, 0);
                    lastCat.add(lastEntry);
                }
                lastStep = step;
            }
            stepsTree.expandPath(new TreePath(root));
            stepsTree.setShowsRootHandles(true);
        } else {
            root.setUserObject(java.util.ResourceBundle.getBundle("intl/AllStepsPanel").getString("AllStepsPanel.no_solution"));
            stepsTree.setRootVisible(true);
        }
        // Reihenfolge der Fische anpassen
        adjustFishes(root);
        model.reload();
        stepsTree.repaint();
    }
    
    private DefaultMutableTreeNode getParent(DefaultMutableTreeNode root, SolutionStep step) {
        Enumeration children = root.children();
        while (children.hasMoreElements()) {
            DefaultMutableTreeNode act = (DefaultMutableTreeNode) children.nextElement();
            if (act.getUserObject() instanceof String) {
                // Ist ein Knoten für einen Step -> ersten Step suchen
                boolean found = false;
                Enumeration nodes = act.children();
                while (nodes.hasMoreElements()) {
                    DefaultMutableTreeNode node = (DefaultMutableTreeNode)nodes.nextElement();
                    if (node.getUserObject() instanceof SolutionStep) {
                        SolutionStep nodeStep = (SolutionStep)node.getUserObject();
                        if (step.isEquivalent(nodeStep)) {
                            return (DefaultMutableTreeNode) node.getParent();
                        } else if (step.isSubStep(nodeStep)) {
                            found = true;
                            break;
                        } else {
                            DefaultMutableTreeNode ret = getParent(act, step);
                            if (ret != null) {
                                // gefunden!
                                return ret;
                            }
                        }
                    }
                }
                if (found) {
                    // gefunden
                    return act;
                }
            }
        }
        // nichts gefunden!
        return null;
    }
    
    /**
     * Mit Sortierung allein kann nicht sichergestellt werden, dass immer der
     * kleinste Fisch angezeigt wird; daher wird das in einem eigenen
     * Durchlauf erledigt:
     *
     *  - Auf jeder Ebene wird zunächst jeder Knoten mit Kindern rekursiv behandelt
     *    (stellt sicher, dass jeder Knoten den kleinsten Step enthält)
     *  - Anschließend werden alle nicht-String-Knoten durchgegangen, der Knoten
     *    mit dem kleinsten Step-Typ wird mit dem ersten Knoten vertauscht,
     *    der String-Knoten wird angepasst
     */
    private void adjustFishes(DefaultMutableTreeNode root) {
        if (root.getChildCount() == 0) {
            return;
        }
        
        // zuerst die Rekursion
        Enumeration nodes = root.children();
        while (nodes.hasMoreElements()) {
            DefaultMutableTreeNode nextNode = (DefaultMutableTreeNode)nodes.nextElement();
            if (nextNode.getChildCount() > 0) {
                adjustFishes(nextNode);
            }
        }
        // wenn das erste Kind wieder ein String ist, sind wir bei root angelangt -> fertig
        if (((DefaultMutableTreeNode)root.getChildAt(0)).getUserObject() instanceof String) {
            return;
        }
        // ok, jeder Knoten enthält den kleinsten Fish -> aktuelle Ebene bereinigen
        int typeOrdinal = -1;
        boolean isString = false;
        if (root.getUserObject() instanceof String) {
            SolutionStep step = (SolutionStep)((DefaultMutableTreeNode)root.getChildAt(0)).getUserObject();
            typeOrdinal = step.getType().ordinal();
            isString = true;
        } else {
            typeOrdinal = ((SolutionStep)root.getUserObject()).getType().ordinal();
        }
        int index = 0;
        int smallestIndex = -1;
        nodes = root.children();
        while (nodes.hasMoreElements()) {
            DefaultMutableTreeNode nextNode = (DefaultMutableTreeNode)nodes.nextElement();
            if (nextNode.getUserObject() instanceof String) {
                // SubSteps, hier uninteressant
                continue;
            }
            int actOrdinal = ((SolutionStep)nextNode.getUserObject()).getType().ordinal();
            if (actOrdinal < typeOrdinal) {
                typeOrdinal = actOrdinal;
                smallestIndex = index;
            }
            index++;
        }
        // ok, gefunden -> wenn nötig anpassen
        if (smallestIndex > -1) {
            SolutionStep step = (SolutionStep)((DefaultMutableTreeNode)root.getChildAt(smallestIndex)).getUserObject();
            if (isString) {
                // mit dem ersten Kind tauschen
                ((DefaultMutableTreeNode)root.getChildAt(smallestIndex)).setUserObject(
                        ((DefaultMutableTreeNode)root.getChildAt(0)).getUserObject());
                ((DefaultMutableTreeNode)root.getChildAt(0)).setUserObject(step);
                // String in root anpassen
                root.setUserObject(step.getCandidateString());
            } else {
                // mit root tauschen
                ((DefaultMutableTreeNode)root.getChildAt(smallestIndex)).setUserObject(root.getUserObject());
                root.setUserObject(step);
            }
        }
    }
    
    /**
     * Sucht die richtige Position in der obersten Ebene des Baumes (hinter dem letzten
     * Step mit gleich viel zu löschenden Kandidaten)
     */
    private int getTopLevelIndex(DefaultMutableTreeNode root, SolutionStep step) {
        int index = 0;
        Enumeration nodes = root.children();
        while (nodes.hasMoreElements()) {
            DefaultMutableTreeNode nextNode = (DefaultMutableTreeNode)nodes.nextElement();
            SolutionStep actStep = getStepFromNode(nextNode);
            if (actStep.getCandidatesToDelete().size() < step.getCandidatesToDelete().size()) {
                break;
            }
            index++;
        }
        return index;
    }
    
    private SolutionStep getStepFromNode(DefaultMutableTreeNode node) {
        if (node.getUserObject() instanceof SolutionStep) {
            return (SolutionStep) node.getUserObject();
        } else if (node.getUserObject() instanceof String) {
            // erstes Kind suchen, das ein SolutionStep ist
            Enumeration nodes = node.children();
            while (nodes.hasMoreElements()) {
                DefaultMutableTreeNode nextNode = (DefaultMutableTreeNode)nodes.nextElement();
                if (nextNode.getUserObject() instanceof SolutionStep) {
                    return (SolutionStep)nextNode.getUserObject();
                }
            }
        }
        return null;
    }
    
    @Override
    public void valueChanged(TreeSelectionEvent e) {
        DefaultMutableTreeNode last = (DefaultMutableTreeNode)stepsTree.getLastSelectedPathComponent();
        if (last != null) {
            if (last.getUserObject() instanceof String) {
                // Erstes Step-Kind anzeigen
                Enumeration children = last.children();
                while (children.hasMoreElements()) {
                    DefaultMutableTreeNode act = (DefaultMutableTreeNode)children.nextElement();
                    if (act.getUserObject() instanceof SolutionStep) {
                        mainFrame.setSolutionStep((SolutionStep)act.getUserObject(), true);
                        break;
                    }
                }
            } else {
                mainFrame.setSolutionStep((SolutionStep)last.getUserObject(), true);
            }
        }
    }
    
    public void setSudoku(Sudoku sudoku) {
        this.sudoku = sudoku;
    }
    
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton addToSolutionButton;
    private javax.swing.JButton configureButton;
    private javax.swing.JButton findButton;
    private javax.swing.JCheckBox forcingChainsCheckBox;
    private javax.swing.JCheckBox forcingNetsCheckBox;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JPanel jPanel2;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JCheckBox krakenFishCheckBox;
    private javax.swing.JTree stepsTree;
    // End of variables declaration//GEN-END:variables
    
}
