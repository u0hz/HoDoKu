/*
 * Copyright (C) 2008  Bernhard Hobiger
 *
 * This file is part of HoDoKu.
 *
 * HoDoKu is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * HoDoKu is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with HoDoKu. If not, see <http://www.gnu.org/licenses/>.
 */

package sudoku;

import java.util.Enumeration;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.JOptionPane;
import javax.swing.event.TreeSelectionEvent;
import javax.swing.event.TreeSelectionListener;
import javax.swing.tree.DefaultMutableTreeNode;
import javax.swing.tree.DefaultTreeModel;
import javax.swing.tree.TreePath;
import javax.swing.tree.TreeSelectionModel;

/**
 *
 * @author  Bernhard Hobiger
 */
public class AllStepsPanel extends javax.swing.JPanel implements TreeSelectionListener, Runnable {
    private static String[] fishSizes = { "2", "3", "4", "5", "6", "7" };
    private static String[] finSizes = { "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10" };
    
    private Sudoku sudoku;
    private List<SolutionStep> steps;
    private MainFrame mainFrame;
    private DefaultTreeModel model;
    
    /** Creates new form AllStepsPanel */
    public AllStepsPanel(MainFrame mainFrame, Sudoku sudoku) {
        this.mainFrame = mainFrame;
        this.setSudoku(sudoku);
        
        initComponents();
        
        resetPanel();
        stepsTree.getSelectionModel().setSelectionMode(TreeSelectionModel.SINGLE_TREE_SELECTION);
        stepsTree.addTreeSelectionListener(this);
        
        for (int i = 0; i < fishSizes.length; i++) {
            groesseVonComboBox.addItem(fishSizes[i]);
            groesseBisComboBox.addItem(fishSizes[i]);
        }
        for (int i = 0; i < finSizes.length; i++) {
            maxFinsComboBox.addItem(finSizes[i]);
            maxEndoFinsComboBox.addItem(finSizes[i]);
        }
        //groesseBisComboBox.setSelectedIndex(2);
        maxFinsComboBox.setSelectedIndex(5);
        maxEndoFinsComboBox.setSelectedIndex(0);
    }
    
    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jPanel1 = new javax.swing.JPanel();
        groesseVonLabel = new javax.swing.JLabel();
        groesseVonComboBox = new javax.swing.JComboBox();
        groesseBisLabel = new javax.swing.JLabel();
        groesseBisComboBox = new javax.swing.JComboBox();
        maxFinsLabel = new javax.swing.JLabel();
        maxFinsComboBox = new javax.swing.JComboBox();
        maxEndoFinsLabel = new javax.swing.JLabel();
        maxEndoFinsComboBox = new javax.swing.JComboBox();
        forcingChainsCheckBox = new javax.swing.JCheckBox();
        forcingNetsCheckBox = new javax.swing.JCheckBox();
        jPanel2 = new javax.swing.JPanel();
        findButton = new javax.swing.JButton();
        addToSolutionButton = new javax.swing.JButton();
        jScrollPane1 = new javax.swing.JScrollPane();
        stepsTree = new javax.swing.JTree();

        setLayout(new java.awt.BorderLayout());

        java.util.ResourceBundle bundle = java.util.ResourceBundle.getBundle("intl/AllStepsPanel"); // NOI18N
        jPanel1.setBorder(javax.swing.BorderFactory.createTitledBorder(bundle.getString("AllStepsPanel.jPanel1.border.title"))); // NOI18N

        groesseVonLabel.setDisplayedMnemonic(java.util.ResourceBundle.getBundle("intl/AllStepsPanel").getString("AllStepsPanel.groesseVonLabel.mnemonic").charAt(0));
        groesseVonLabel.setLabelFor(groesseVonComboBox);
        groesseVonLabel.setText(bundle.getString("AllStepsPanel.groesseVonLabel.text")); // NOI18N

        groesseBisLabel.setDisplayedMnemonic(java.util.ResourceBundle.getBundle("intl/AllStepsPanel").getString("AllStepsPanel.groesseBisLabel.mnemonic").charAt(0));
        groesseBisLabel.setLabelFor(groesseBisComboBox);
        groesseBisLabel.setText(bundle.getString("AllStepsPanel.groesseBisLabel.text")); // NOI18N

        maxFinsLabel.setDisplayedMnemonic(java.util.ResourceBundle.getBundle("intl/AllStepsPanel").getString("AllStepsPanel.maxFinsLabel.mnemonic").charAt(0));
        maxFinsLabel.setLabelFor(maxFinsComboBox);
        maxFinsLabel.setText(bundle.getString("AllStepsPanel.maxFinsLabel.text")); // NOI18N

        maxEndoFinsLabel.setDisplayedMnemonic(java.util.ResourceBundle.getBundle("intl/AllStepsPanel").getString("AllStepsPanel.maxEndoFinsLabel.mnemonic").charAt(0));
        maxEndoFinsLabel.setLabelFor(maxEndoFinsComboBox);
        maxEndoFinsLabel.setText(bundle.getString("AllStepsPanel.maxEndoFinsLabel.text")); // NOI18N

        forcingChainsCheckBox.setMnemonic(java.util.ResourceBundle.getBundle("intl/AllStepsPanel").getString("AllStepsPanel.forcingChainsCheckBox.mnemonic").charAt(0));
        forcingChainsCheckBox.setText(bundle.getString("AllStepsPanel.forcingChainsCheckBox.text")); // NOI18N
        forcingChainsCheckBox.setBorder(javax.swing.BorderFactory.createEmptyBorder(0, 0, 0, 0));
        forcingChainsCheckBox.setMargin(new java.awt.Insets(0, 0, 0, 0));

        forcingNetsCheckBox.setMnemonic(java.util.ResourceBundle.getBundle("intl/AllStepsPanel").getString("AllStepsPanel.forcingNetsCheckBox.mnemonic").charAt(0));
        forcingNetsCheckBox.setText(bundle.getString("AllStepsPanel.forcingNetsCheckBox.text")); // NOI18N
        forcingNetsCheckBox.setBorder(javax.swing.BorderFactory.createEmptyBorder(0, 0, 0, 0));
        forcingNetsCheckBox.setMargin(new java.awt.Insets(0, 0, 0, 0));

        javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);
        jPanel1.setLayout(jPanel1Layout);
        jPanel1Layout.setHorizontalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addComponent(groesseVonLabel)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(groesseVonComboBox, javax.swing.GroupLayout.PREFERRED_SIZE, 45, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(groesseBisLabel)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(groesseBisComboBox, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(maxFinsLabel)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(maxFinsComboBox, javax.swing.GroupLayout.PREFERRED_SIZE, 41, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(maxEndoFinsLabel)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(maxEndoFinsComboBox, javax.swing.GroupLayout.PREFERRED_SIZE, 43, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addComponent(forcingChainsCheckBox)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(forcingNetsCheckBox)))
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        jPanel1Layout.linkSize(javax.swing.SwingConstants.HORIZONTAL, new java.awt.Component[] {groesseBisComboBox, groesseVonComboBox, maxEndoFinsComboBox, maxFinsComboBox});

        jPanel1Layout.setVerticalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(groesseVonLabel)
                    .addComponent(groesseVonComboBox, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(groesseBisLabel)
                    .addComponent(groesseBisComboBox, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(maxFinsLabel)
                    .addComponent(maxFinsComboBox, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(maxEndoFinsLabel)
                    .addComponent(maxEndoFinsComboBox, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(forcingChainsCheckBox)
                    .addComponent(forcingNetsCheckBox))
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        add(jPanel1, java.awt.BorderLayout.NORTH);

        findButton.setMnemonic(java.util.ResourceBundle.getBundle("intl/AllStepsPanel").getString("AllStepsPanel.findButton.mnemonic").charAt(0));
        findButton.setText(bundle.getString("AllStepsPanel.findButton.text")); // NOI18N
        findButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                findButtonActionPerformed(evt);
            }
        });

        addToSolutionButton.setMnemonic(java.util.ResourceBundle.getBundle("intl/AllStepsPanel").getString("AllStepsPanel.addToSolution.mnemonic").charAt(0));
        addToSolutionButton.setText(bundle.getString("AllStepsPanel.addToSolutionButton.text")); // NOI18N
        addToSolutionButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                addToSolutionButtonActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout jPanel2Layout = new javax.swing.GroupLayout(jPanel2);
        jPanel2.setLayout(jPanel2Layout);
        jPanel2Layout.setHorizontalGroup(
            jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel2Layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(findButton)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(addToSolutionButton)
                .addContainerGap(102, Short.MAX_VALUE))
        );

        jPanel2Layout.linkSize(javax.swing.SwingConstants.HORIZONTAL, new java.awt.Component[] {addToSolutionButton, findButton});

        jPanel2Layout.setVerticalGroup(
            jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel2Layout.createSequentialGroup()
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(findButton)
                    .addComponent(addToSolutionButton))
                .addContainerGap())
        );

        add(jPanel2, java.awt.BorderLayout.SOUTH);

        jScrollPane1.setViewportView(stepsTree);

        add(jScrollPane1, java.awt.BorderLayout.CENTER);
    }// </editor-fold>//GEN-END:initComponents
    
    private void addToSolutionButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_addToSolutionButtonActionPerformed
        DefaultMutableTreeNode last = (DefaultMutableTreeNode)stepsTree.getLastSelectedPathComponent();
        SolutionStep actStep = null;
        if (last != null) {
            if (last.getUserObject() instanceof String) {
                // Erstes Step-Kind holen
                Enumeration children = last.children();
                while (children.hasMoreElements()) {
                    DefaultMutableTreeNode act = (DefaultMutableTreeNode)children.nextElement();
                    if (act.getUserObject() instanceof SolutionStep) {
                        actStep = (SolutionStep)act.getUserObject();
                        break;
                    }
                }
            } else {
                actStep = (SolutionStep)last.getUserObject();
            }
        }
        if (actStep == null) {
            JOptionPane.showMessageDialog(this, java.util.ResourceBundle.getBundle("intl/AllStepsPanel").getString("AllStepsPanel.no_solution_selected"), 
                    java.util.ResourceBundle.getBundle("intl/AllStepsPanel").getString("AllStepsPanel.error"), JOptionPane.ERROR_MESSAGE);
            return;
        }
        mainFrame.getSolutionPanel().addStep(actStep);
    }//GEN-LAST:event_addToSolutionButtonActionPerformed
    
    private void findButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_findButtonActionPerformed
        if (sudoku == null) {
            JOptionPane.showMessageDialog(this, java.util.ResourceBundle.getBundle("intl/AllStepsPanel").getString("AllStepsPanel.sudoku_not_set"), 
                    java.util.ResourceBundle.getBundle("intl/AllStepsPanel").getString("AllStepsPanel.error"), JOptionPane.ERROR_MESSAGE);
            return;
        }
        resetTreeNodes();
        new Thread(this).start();
    }//GEN-LAST:event_findButtonActionPerformed
        
    @Override
    public void run() {
        int minSize = Integer.parseInt((String)groesseVonComboBox.getSelectedItem());
        int maxSize = Integer.parseInt((String)groesseBisComboBox.getSelectedItem());
        int maxFins = Integer.parseInt((String)maxFinsComboBox.getSelectedItem());
        int maxEndoFins = Integer.parseInt((String)maxEndoFinsComboBox.getSelectedItem());
        boolean forcingChains = forcingChainsCheckBox.isSelected();
        boolean forcingNets = forcingNetsCheckBox.isSelected();
        
        FindAllStepsProgressDialog dlg = new FindAllStepsProgressDialog(mainFrame, true, sudoku,
                minSize, maxSize, maxFins, maxEndoFins, forcingChains, forcingNets);
        dlg.setVisible(true);
        steps = dlg.getSteps();
        createTreeNodes();
    }
    
    public void resetPanel() {
        model = new DefaultTreeModel(new DefaultMutableTreeNode(java.util.ResourceBundle.getBundle("intl/AllStepsPanel").getString("AllStepsPanel.no_solutions")));
        stepsTree.setModel(model);
        createTreeNodes();
    }
    
    private void resetTreeNodes() {
        DefaultMutableTreeNode root = (DefaultMutableTreeNode)model.getRoot();
        root.removeAllChildren();
        root.setUserObject(java.util.ResourceBundle.getBundle("intl/AllStepsPanel").getString("AllStepsPanel.searching"));
        model.reload();
        stepsTree.setRootVisible(true);
        stepsTree.repaint();
    }
    
    private void createTreeNodes() {
        DefaultMutableTreeNode root = (DefaultMutableTreeNode)model.getRoot();
        root.removeAllChildren();
        if (steps != null && steps.size() > 0) {
            root.setUserObject(java.util.ResourceBundle.getBundle("intl/AllStepsPanel").getString("AllStepsPanel.possible_steps"));
            stepsTree.setRootVisible(false);
            SolutionStep lastStep = null;
            DefaultMutableTreeNode lastCat = null;
            DefaultMutableTreeNode lastEntry = null;
            for (SolutionStep step : steps) {
                // Singles kommen immer ganz oben hin (jedes Single in eine eigene Kategorie); das gleiche gilt für Forcing Chains, die Werte setzen
                // (eigener Durchlauf!)
                //System.out.println(step.toString(2));
                if (step.isSingle() || (step.isForcingChainSet())) {
                    continue;
                }
                Logger.getLogger(AllStepsPanel.class.getName()).log(Level.FINER, step.toString(2));
                if (lastStep == null) {
                    // erster Eintrag
                    Logger.getLogger(AllStepsPanel.class.getName()).log(Level.FINER, step.getCandidateString());
                    lastCat = new DefaultMutableTreeNode(step.getCandidateString());
                    lastEntry = new DefaultMutableTreeNode(step);
                    root.add(lastCat);
                    lastCat.add(lastEntry);
                } else {
                    // normaler Betrieb, mitten im Baum
                    if (step.isEqual(lastStep)) {
                        // gleich -> darunterhängen
                        lastEntry.add(new DefaultMutableTreeNode(step));
                    } else if (step.isEquivalent(lastStep)) {
                        // äquivalent: neuer Eintrag unter lastCat
                        lastEntry = new DefaultMutableTreeNode(step);
                        lastCat.add(lastEntry);
                    } else {
                        // neue Kategorie: prüfen, ob es ein Subset eines bestehenden Eintrags ist
                        Logger.getLogger(AllStepsPanel.class.getName()).log(Level.FINER, step.getCandidateString());
                        lastCat = new DefaultMutableTreeNode(step.getCandidateString());
                        lastEntry = new DefaultMutableTreeNode(step);
                        // doch nicht untereinander
                        //DefaultMutableTreeNode tmp = getParent(root, step);
                        DefaultMutableTreeNode tmp = null;
                        if (tmp == null) {
                            // in oberster Ebene einhängen: richtigen Index suchen
                            // (soll schließlich nach Anzahl zu löschender Kandidaten sortiert sein)
                            root.insert(lastCat, getTopLevelIndex(root, step));
                            //root.add(lastCat);
                        } else {
                            // ist entweder äquivalent oder Subset
                            SolutionStep tmpStep = getStepFromNode(tmp);
                            if (tmpStep.isEquivalent(step)) {
                                // hinter dem äquivalenten Step in parent einfügen
                                DefaultMutableTreeNode parent = (DefaultMutableTreeNode)tmp.getParent();
                                parent.insert(lastCat, parent.getIndex(tmp) + 1);
                            } else {
                                tmp.add(lastCat);
                            }
                        }
                        lastCat.add(lastEntry);
                    }
                }
                lastStep = step;
            }
            for (SolutionStep step : steps) {
                // Singles kommen immer ganz oben hin (jedes Single in eine eigene Kategorie)
                // ACHTUNG: Forcing Chains: Alle Setzoperationen für eine Zelle in eine Kategorie
                // (eigener Durchlauf!)
                if (! step.isSingle() && ! step.isForcingChainSet()) {
                    continue;
                }
                if (step.isForcingChainSet() && step.isEqual(lastStep)) {
                    // gleich -> darunterhängen
                    lastEntry.add(new DefaultMutableTreeNode(step));
                } else {
                    lastCat = new DefaultMutableTreeNode(step.getSingleCandidateString());
                    lastEntry = new DefaultMutableTreeNode(step);
                    root.insert(lastCat, 0);
                    lastCat.add(lastEntry);
                }
                lastStep = step;
            }
            stepsTree.expandPath(new TreePath(root));
            stepsTree.setShowsRootHandles(true);
        } else {
            root.setUserObject(java.util.ResourceBundle.getBundle("intl/AllStepsPanel").getString("AllStepsPanel.no_solution"));
            stepsTree.setRootVisible(true);
        }
        // Reihenfolge der Fische anpassen
        adjustFishes(root);
        model.reload();
        stepsTree.repaint();
    }
    
    private DefaultMutableTreeNode getParent(DefaultMutableTreeNode root, SolutionStep step) {
        Enumeration children = root.children();
        while (children.hasMoreElements()) {
            DefaultMutableTreeNode act = (DefaultMutableTreeNode) children.nextElement();
            if (act.getUserObject() instanceof String) {
                // Ist ein Knoten für einen Step -> ersten Step suchen
                boolean found = false;
                Enumeration nodes = act.children();
                while (nodes.hasMoreElements()) {
                    DefaultMutableTreeNode node = (DefaultMutableTreeNode)nodes.nextElement();
                    if (node.getUserObject() instanceof SolutionStep) {
                        SolutionStep nodeStep = (SolutionStep)node.getUserObject();
                        if (step.isEquivalent(nodeStep)) {
                            return (DefaultMutableTreeNode) node.getParent();
                        } else if (step.isSubStep(nodeStep)) {
                            found = true;
                            break;
                        } else {
                            DefaultMutableTreeNode ret = getParent(act, step);
                            if (ret != null) {
                                // gefunden!
                                return ret;
                            }
                        }
                    }
                }
                if (found) {
                    // gefunden
                    return act;
                }
            }
        }
        // nichts gefunden!
        return null;
    }
    
    /**
     * Mit Sortierung allein kann nicht sichergestellt werden, dass immer der
     * kleinste Fisch angezeigt wird; daher wird das in einem eigenen
     * Durchlauf erledigt:
     *
     *  - Auf jeder Ebene wird zunächst jeder Knoten mit Kindern rekursiv behandelt
     *    (stellt sicher, dass jeder Knoten den kleinsten Step enthält)
     *  - Anschließend werden alle nicht-String-Knoten durchgegangen, der Knoten
     *    mit dem kleinsten Step-Typ wird mit dem ersten Knoten vertauscht,
     *    der String-Knoten wird angepasst
     */
    private void adjustFishes(DefaultMutableTreeNode root) {
        if (root.getChildCount() == 0) {
            return;
        }
        
        // zuerst die Rekursion
        Enumeration nodes = root.children();
        while (nodes.hasMoreElements()) {
            DefaultMutableTreeNode nextNode = (DefaultMutableTreeNode)nodes.nextElement();
            if (nextNode.getChildCount() > 0) {
                adjustFishes(nextNode);
            }
        }
        // wenn das erste Kind wieder ein String ist, sind wir bei root angelangt -> fertig
        if (((DefaultMutableTreeNode)root.getChildAt(0)).getUserObject() instanceof String) {
            return;
        }
        // ok, jeder Knoten enthält den kleinsten Fish -> aktuelle Ebene bereinigen
        int typeOrdinal = -1;
        boolean isString = false;
        if (root.getUserObject() instanceof String) {
            SolutionStep step = (SolutionStep)((DefaultMutableTreeNode)root.getChildAt(0)).getUserObject();
            typeOrdinal = step.getType().ordinal();
            isString = true;
        } else {
            typeOrdinal = ((SolutionStep)root.getUserObject()).getType().ordinal();
        }
        int index = 0;
        int smallestIndex = -1;
        nodes = root.children();
        while (nodes.hasMoreElements()) {
            DefaultMutableTreeNode nextNode = (DefaultMutableTreeNode)nodes.nextElement();
            if (nextNode.getUserObject() instanceof String) {
                // SubSteps, hier uninteressant
                continue;
            }
            int actOrdinal = ((SolutionStep)nextNode.getUserObject()).getType().ordinal();
            if (actOrdinal < typeOrdinal) {
                typeOrdinal = actOrdinal;
                smallestIndex = index;
            }
            index++;
        }
        // ok, gefunden -> wenn nötig anpassen
        if (smallestIndex > -1) {
            SolutionStep step = (SolutionStep)((DefaultMutableTreeNode)root.getChildAt(smallestIndex)).getUserObject();
            if (isString) {
                // mit dem ersten Kind tauschen
                ((DefaultMutableTreeNode)root.getChildAt(smallestIndex)).setUserObject(
                        ((DefaultMutableTreeNode)root.getChildAt(0)).getUserObject());
                ((DefaultMutableTreeNode)root.getChildAt(0)).setUserObject(step);
                // String in root anpassen
                root.setUserObject(step.getCandidateString());
            } else {
                // mit root tauschen
                ((DefaultMutableTreeNode)root.getChildAt(smallestIndex)).setUserObject(root.getUserObject());
                root.setUserObject(step);
            }
        }
    }
    
    /**
     * Sucht die richtige Position in der obersten Ebene des Baumes (hinter dem letzten
     * Step mit gleich viel zu löschenden Kandidaten)
     */
    private int getTopLevelIndex(DefaultMutableTreeNode root, SolutionStep step) {
        int index = 0;
        Enumeration nodes = root.children();
        while (nodes.hasMoreElements()) {
            DefaultMutableTreeNode nextNode = (DefaultMutableTreeNode)nodes.nextElement();
            SolutionStep actStep = getStepFromNode(nextNode);
            if (actStep.getCandidatesToDelete().size() < step.getCandidatesToDelete().size()) {
                break;
            }
            index++;
        }
        return index;
    }
    
    private SolutionStep getStepFromNode(DefaultMutableTreeNode node) {
        if (node.getUserObject() instanceof SolutionStep) {
            return (SolutionStep) node.getUserObject();
        } else if (node.getUserObject() instanceof String) {
            // erstes Kind suchen, das ein SolutionStep ist
            Enumeration nodes = node.children();
            while (nodes.hasMoreElements()) {
                DefaultMutableTreeNode nextNode = (DefaultMutableTreeNode)nodes.nextElement();
                if (nextNode.getUserObject() instanceof SolutionStep) {
                    return (SolutionStep)nextNode.getUserObject();
                }
            }
        }
        return null;
    }
    
    @Override
    public void valueChanged(TreeSelectionEvent e) {
        DefaultMutableTreeNode last = (DefaultMutableTreeNode)stepsTree.getLastSelectedPathComponent();
        if (last != null) {
            if (last.getUserObject() instanceof String) {
                // Erstes Step-Kind anzeigen
                Enumeration children = last.children();
                while (children.hasMoreElements()) {
                    DefaultMutableTreeNode act = (DefaultMutableTreeNode)children.nextElement();
                    if (act.getUserObject() instanceof SolutionStep) {
                        mainFrame.setSolutionStep((SolutionStep)act.getUserObject(), true);
                        break;
                    }
                }
            } else {
                mainFrame.setSolutionStep((SolutionStep)last.getUserObject(), true);
            }
        }
    }
    
    public void setSudoku(Sudoku sudoku) {
        this.sudoku = sudoku;
    }
    
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton addToSolutionButton;
    private javax.swing.JButton findButton;
    private javax.swing.JCheckBox forcingChainsCheckBox;
    private javax.swing.JCheckBox forcingNetsCheckBox;
    private javax.swing.JComboBox groesseBisComboBox;
    private javax.swing.JLabel groesseBisLabel;
    private javax.swing.JComboBox groesseVonComboBox;
    private javax.swing.JLabel groesseVonLabel;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JPanel jPanel2;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JComboBox maxEndoFinsComboBox;
    private javax.swing.JLabel maxEndoFinsLabel;
    private javax.swing.JComboBox maxFinsComboBox;
    private javax.swing.JLabel maxFinsLabel;
    private javax.swing.JTree stepsTree;
    // End of variables declaration//GEN-END:variables
    
}
